Payment Processing
------------------

Payment Protocol
~~~~~~~~~~~~~~~~

To request payment using the payment protocol, you use an extended (but backwards-compatible) :term:`“bitcoin:” URI <Bitcoin uri>`. For example:

|Warning icon| **Warning:** The payment protocol is considered to be deprecated and will be removed in a later version of Bitcoin Core. The protocol has multiple security design flaws and implementation flaws in some wallets. Users will begin receiving deprecation warnings in Bitcoin Core version 0.18 when using `BIP70 <https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki>`__ URI’s. Merchants should transition away from `BIP70 <https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki>`__ to more secure options such as `BIP21 <https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki>`__. Merchants should never require `BIP70 <https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki>`__ payments and should provide `BIP21 <https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki>`__ fallbacks.

::

   bitcoin:mjSk1Ny9spzU2fouzYgLqGUD8U41iR35QN\
   ?amount=0.10\
   &label=Example+Merchant\
   &message=Order+of+flowers+%26+chocolates\
   &r=https://example.com/pay.php/invoice%3Dda39a3ee

The browser, QR code reader, or other program processing the URI opens the spender’s Bitcoin wallet program on the URI. If the wallet program is aware of the payment protocol, it accesses the URL specified in the :term:`“r” <R parameter>` parameter, which should provide it with a serialized :term:`PaymentRequest <PaymentRequest>` served with the `MIME <https://en.wikipedia.org/wiki/Internet_media_type>`__ type ``application/bitcoin-paymentrequest``.

**Resource:** Gavin Andresen’s `Payment Request Generator <https://github.com/gavinandresen/paymentrequest/blob/master/php/demo_website/createpaymentrequest.php>`__ generates custom example URIs and payment requests for use with testnet.

PaymentRequest & PaymentDetails
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The :term:`PaymentRequest <PaymentRequest>` is created with data structures built using Google’s `Protocol Buffers <https://developers.google.com/protocol-buffers/>`__. `BIP70 <https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki>`__ describes these data structures in the non-sequential way they’re defined in the payment request `protocol buffer <https://developers.google.com/protocol-buffers/>`__ code, but the text below will describe them in a more linear order using a simple (but functional) Python CGI program. (For brevity and clarity, many normal CGI best practices are not used in this program.)

The full sequence of events is illustrated below, starting with the spender clicking a :term:`“bitcoin:” URI <Bitcoin uri>` or scanning a ``bitcoin:`` QR code.

.. figure:: /img/dev/en-payment-protocol.svg
   :alt: BIP70 Payment Protocol

   BIP70 Payment Protocol

For the script to use the `protocol buffer <https://developers.google.com/protocol-buffers/>`__, you will need a copy of Google’s `Protocol Buffer <https://developers.google.com/protocol-buffers/>`__ compiler (``protoc``), which is available in most modern Linux package managers and `directly from Google. <https://developers.google.com/protocol-buffers/>`__ Non-Google `protocol buffer <https://developers.google.com/protocol-buffers/>`__ compilers are available for a variety of programming languages. You will also need a copy of the :term:`PaymentRequest <PaymentRequest>` `Protocol Buffer description <https://github.com/bitcoin/bitcoin/blob/0.19/src/qt/paymentrequest.proto>`__ from the Bitcoin Core source code.

Initialization Code
'''''''''''''''''''

With the Python code generated by ``protoc``, we can start our simple CGI program.

.. highlight:: python

::

   #!/usr/bin/env python

   ## This is the code generated by protoc --python_out=./ [paymentrequest][paymentrequest].proto
   from paymentrequest_pb2 import *

   ## Load some functions
   from time import time
   from sys import stdout
   from OpenSSL.crypto import FILETYPE_PEM, load_privatekey, sign

   ## Copy three of the classes created by protoc into objects we can use
   details = [PaymentDetails][paymentdetails]()
   request = [PaymentRequest][paymentrequest]()
   x509 = [X509Certificates][x509certificates]()

The startup code above is quite simple, requiring nothing but the epoch (Unix date) time function, the standard out file descriptor, a few functions from the OpenSSL library, and the data structures and functions created by ``protoc``.

Configuration Code
''''''''''''''''''

Next, we’ll set configuration settings which will typically only change when the receiver wants to do something differently. The code pushes a few settings into the ``request`` (:term:`PaymentRequest <PaymentRequest>`) and ``details`` (:term:`PaymentDetails <PaymentDetails>`) objects. When we serialize them, :term:`PaymentDetails <PaymentDetails>` will be contained within the :term:`PaymentRequest <PaymentRequest>`.

.. highlight:: python

::

   ## SSL Signature method
   request.pki_type = "x509+sha256"  ## Default: none

   ## Mainnet or testnet?
   details.[network][network] = "test"  ## Default: main

   ## Postback URL
   details.payment_url = "https://example.com/pay.py"

   ## [PaymentDetails][paymentdetails] version number
   request.payment_details_version = 1  ## Default: 1

   ## [Certificate chain][certificate chain]
   x509.certificate.append(file("/etc/apache2/example.com-cert.[der][der]", "r").read())
   #x509.certificate.append(file("/some/intermediate/cert.[der][der]", "r").read())

   ## Load private SSL key into memory for signing later
   priv_key = "/etc/apache2/example.com-key.pem"
   pw = "test"  ## Key password
   private_key = load_privatekey(FILETYPE_PEM, file(priv_key, "r").read(), pw)

Each line is described below.

.. highlight:: python

::

   request.pki_type = "x509+sha256"  ## Default: none

:term:`“pki_type” <PP pki type>`: (optional) tell the receiving wallet program what :term:`Public-Key Infrastructure <PKI>` (:term:`PKI <PKI>`) type you’re using to cryptographically sign your :term:`PaymentRequest <PaymentRequest>` so that it can’t be modified by a `man-in-the-middle <https://en.wikipedia.org/wiki/Man-in-the-middle_attack>`__ attack.

If you don’t want to sign the :term:`PaymentRequest <PaymentRequest>`, you can choose a :term:`“pki_type” <PP pki type>` of ``none`` (the default).

If you do choose the sign the :term:`PaymentRequest <PaymentRequest>`, you currently have two options defined by `BIP70 <https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki>`__: ``x509+sha1`` and ``x509+sha256``. Both options use the `X.509 <https://en.wikipedia.org/wiki/X.509>`__ certificate system, the same system used for HTTP Secure (HTTPS). To use either option, you will need a certificate signed by a certificate authority or one of their intermediaries. (A self-signed certificate will not work.)

Each wallet program may choose which certificate authorities to trust, but it’s likely that they’ll trust whatever certificate authorities their operating system trusts. If the wallet program doesn’t have a full operating system, as might be the case for small hardware wallets, `BIP70 <https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki>`__ suggests they use the `Mozilla Root Certificate Store <https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/>`__. In general, if a certificate works in your web browser when you connect to your webserver, it will work for your :term:`PaymentRequests <PaymentRequest>`.

.. highlight:: python

::

   details.[network][network] = "test"  ## Default: main

``network``: (optional) tell the spender’s wallet program what Bitcoin `network <../devguide/p2p_network.html>`__ you’re using; `BIP70 <https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki>`__ defines “main” for mainnet (actual payments) and “test” for testnet (like mainnet, but fake satoshis are used). If the wallet program doesn’t run on the `network <../devguide/p2p_network.html>`__ you indicate, it will reject the :term:`PaymentRequest <PaymentRequest>`.

.. highlight:: python

::

   details.payment_url = "https://example.com/pay.py"

``payment_url``: (required) tell the spender’s wallet program where to send the Payment message (described later). This can be a static URL, as in this example, or a variable URL such as ``https://example.com/pay.py?invoice=123.`` It should usually be an HTTPS address to prevent `man-in-the-middle <https://en.wikipedia.org/wiki/Man-in-the-middle_attack>`__ attacks from modifying the message.

.. highlight:: python

::

   request.payment_details_version = 1  ## Default: 1

``payment_details_version``: (optional) tell the spender’s wallet program what version of the :term:`PaymentDetails <PaymentDetails>` you’re using. As of this writing, the only version is version 1.

.. highlight:: python

::

   ## This is the pubkey/certificate corresponding to the private SSL key
   ## that we'll use to sign:
   x509.certificate.append(file("/etc/apache2/example.com-cert.[der][der]", "r").read())

``x509certificates``: (required for signed :term:`PaymentRequests <PaymentRequest>`) you must provide the public SSL key/certificate corresponding to the private SSL key you’ll use to sign the :term:`PaymentRequest <PaymentRequest>`. The certificate must be in ASN.1/\ `DER format <https://en.wikipedia.org/wiki/X.690#DER_encoding>`__.

.. highlight:: python

::

   ## If the pubkey/cert above didn't have the signature of a root
   ## certificate authority, we'd then append the [intermediate certificate][intermediate certificate]
   ## which signed it:
   #x509.certificate.append(file("/some/intermediate/cert.[der][der]", "r").read())

You must also provide any :term:`intermediate certificates <Intermediate certificate>` necessary to link your certificate to the :term:`root certificate <Root certificate>` of a certificate authority trusted by the spender’s software, such as a certificate from the Mozilla root store.

The certificates must be provided in a specific order—the same order used by Apache’s ``SSLCertificateFile`` directive and other server software. The figure below shows the :term:`certificate chain <Certificate chain>` of the www.bitcoin.org `X.509 <https://en.wikipedia.org/wiki/X.509>`__ certificate and how each certificate (except the :term:`root certificate <Root certificate>`) would be loaded into the :ref:`X509Certificates <term-x509certificates>` `protocol buffer <https://developers.google.com/protocol-buffers/>`__ message.

.. figure:: /img/dev/en-cert-order.svg
   :alt: X509Certificates Loading Order

   X509Certificates Loading Order

To be specific, the first certificate provided must be the `X.509 <https://en.wikipedia.org/wiki/X.509>`__ certificate corresponding to the private SSL key which will make the signature, called the :term:`leaf certificate <Leaf certificate>`. Any :term:`intermediate certificates <Intermediate certificate>` necessary to link that signed public SSL key to the :term:`root certificate <Root certificate>` (the certificate authority) are attached separately, with each certificate in `DER format <https://en.wikipedia.org/wiki/X.690#DER_encoding>`__ bearing the signature of the certificate that follows it all the way to (but not including) the :term:`root certificate <Root certificate>`.

.. highlight:: python

::

   priv_key = "/etc/apache2/example.com-key.pem"
   pw = "test"  ## Key password
   private_key = load_privatekey(FILETYPE_PEM, file(priv_key, "r").read(), pw)

(Required for signed :term:`PaymentRequests <PaymentRequest>`) you will need a private SSL key in a format your SSL library supports (`DER format <https://en.wikipedia.org/wiki/X.690#DER_encoding>`__ is not required). In this program, we’ll load it from a PEM file. (Embedding your passphrase in your CGI code, as done here, is obviously a bad idea in real life.)

The private SSL key will not be transmitted with your request. We’re only loading it into memory here so we can use it to sign the request later.

Code Variables
''''''''''''''

Now let’s look at the variables your CGI program will likely set for each payment.

.. highlight:: python

::

   ## Amount of the request
   amount = 10000000  ## In satoshis

   ## P2PKH pubkey hash
   pubkey_hash = "2b14950b8d31620c6cc923c5408a701b1ec0a020"
   ## P2PKH pubkey script entered as hex and converted to binary
   # OP_DUP OP_HASH160 <push 20 bytes> <pubKey hash> OP_EQUALVERIFY OP_CHECKSIG
   #   76       a9            14       <pubKey hash>        88          ac
   hex_script = "76" + "a9" + "14" + pubkey_hash + "88" + "ac"
   serialized_script = hex_script.decode("hex")

   ## Load amount and pubkey script into [PaymentDetails][paymentdetails]
   details.outputs.add(amount = amount, script = serialized_script)

   ## Memo to display to the spender
   details.memo = "Flowers & chocolates"

   ## Data which should be returned to you with the payment
   details.merchant_data = "Invoice #123"

Each line is described below.

.. highlight:: python

::

   amount = 10000000  ## In satoshis (=100 mBTC)

:term:`“amount” <PP amount>`: (optional) the :term:`amount <PP amount>` you want the spender to pay. You’ll probably get this value from your shopping cart application or :term:`fiat <Fiat>`-to-BTC exchange rate conversion tool. If you leave the amount blank, the wallet program will prompt the spender how much to pay (which can be useful for donations).

.. highlight:: python

::

   pubkey_hash = "2b14950b8d31620c6cc923c5408a701b1ec0a020"
   # OP_DUP OP_HASH160 <push 20 bytes> <pubKey hash> OP_EQUALVERIFY OP_CHECKSIG
   #   76       a9            14       <pubKey hash>        88          ac
   hex_script = "76" + "a9" + "14" + pubkey_hash + "88" + "ac"
   serialized_script = hex_script.decode("hex")

:term:`“script” <PP script>`: (required) You must specify the pubkey script you want the spender to pay—any valid pubkey script is acceptable. In this example, we’ll request payment to a P2PKH pubkey script.

First we get a pubkey hash. The hash above is the hash form of the address used in the URI examples throughout this section, mjSk1Ny9spzU2fouzYgLqGUD8U41iR35QN.

Next, we plug that hash into the standard P2PKH pubkey script using hex, as illustrated by the code comments.

Finally, we convert the pubkey script from hex into its serialized form.

.. highlight:: python

::

   details.outputs.add(amount = amount, script = serialized_script)

``outputs``: (required) add the pubkey script and (optional) amount to the :term:`PaymentDetails <PaymentDetails>` outputs array.

It’s possible to specify multiple :term:`“scripts” <PP script>` and ``amounts`` as part of a :term:`merge avoidance <Merge avoidance>` strategy, described later in the `Merge Avoidance subsection <../devguide/payment_processing.html#merge-avoidance>`__. However, effective :term:`merge avoidance <Merge avoidance>` is not possible under the base `BIP70 <https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki>`__ rules in which the spender pays each :term:`“script” <PP script>` the exact amount specified by its paired :term:`“amount” <PP amount>`. If the amounts are omitted from all :term:`“amount” <PP amount>`/:term:`“script” <PP script>` pairs, the spender will be prompted to choose an amount to pay.

.. highlight:: python

::

   details.memo = "Flowers & chocolates"

:term:`“memo” <PP memo>`: (optional) add a memo which will be displayed to the spender as plain UTF-8 text. Embedded HTML or other markup will not be processed.

.. highlight:: python

::

   details.merchant_data = "Invoice #123"

:term:`“merchant_data” <PP merchant data>`: (optional) add arbitrary data which should be sent back to the receiver when the invoice is paid. You can use this to track your invoices, although you can more reliably track payments by generating a :term:`unique address <Unique address>` for each payment and then tracking when it gets paid.

The :term:`“memo” <PP memo>` field can be arbitrarily long, but if you make them too long, you’ll run into the 50,000 byte limit on the entire :term:`PaymentRequest <PaymentRequest>`, which includes the often several kilobytes given over to storing the :term:`certificate chain <Certificate chain>`. As will be described in a later subsection, the :term:`“memo” <PP memo>` field can be used by the spender after payment as part of a cryptographically-proven :term:`receipt <Receipt>`.

Derivable Data
''''''''''''''

Next, let’s look at some information your CGI program can automatically derive.

.. highlight:: python

::

   ## Request creation time
   details.time = int(time()) ## Current epoch (Unix) time

   ## Request expiration time
   details.expires = int(time()) + 60 * 10  ## 10 minutes from now

   ## [PaymentDetails][paymentdetails] is complete; serialize it and store it in [PaymentRequest][paymentrequest]
   request.serialized_payment_details = details.SerializeToString()

   ## Serialized [certificate chain][certificate chain]
   request.pki_data = x509.SerializeToString()

   ## Initialize signature field so we can sign the full [PaymentRequest][paymentrequest]
   request.signature = ""

   ## Sign [PaymentRequest][paymentrequest]
   request.signature = sign(private_key, request.SerializeToString(), "sha256")

Each line is described below.

.. highlight:: python

::

   details.time = int(time()) ## Current epoch (Unix) time

``time``: (required) :term:`PaymentRequests <PaymentRequest>` must indicate when they were created in number of seconds elapsed since 1970-01-01T00:00 UTC (`Unix epoch time <https://en.wikipedia.org/wiki/Unix_time>`__ format).

.. highlight:: python

::

   details.expires = int(time()) + 60 * 10  ## 10 minutes from now

:term:`“expires” <PP expires>`: (optional) the :term:`PaymentRequest <PaymentRequest>` may also set an :term:`“expires” <PP expires>` time after which they’re no longer valid. You probably want to give receivers the ability to configure the expiration time delta; here we used the reasonable choice of 10 minutes. If this request is tied to an order total based on a :term:`fiat <Fiat>`-to-satoshis exchange rate, you probably want to base this on a delta from the time you got the exchange rate.

.. highlight:: python

::

   request.serialized_payment_details = details.SerializeToString()

``serialized_payment_details``: (required) we’ve now set everything we need to create the :term:`PaymentDetails <PaymentDetails>`, so we’ll use the SerializeToString function from the `protocol buffer <https://developers.google.com/protocol-buffers/>`__ code to store the :term:`PaymentDetails <PaymentDetails>` in the appropriate field of the :term:`PaymentRequest <PaymentRequest>`.

.. highlight:: python

::

   request.pki_data = x509.SerializeToString()

``pki_data``: (required for signed :term:`PaymentRequests <PaymentRequest>`) serialize the :term:`certificate chain <Certificate chain>` :term:`PKI data <PP pki data>` and store it in the :term:`PaymentRequest <PaymentRequest>`

.. highlight:: python

::

   request.signature = ""

We’ve filled out everything in the :term:`PaymentRequest <PaymentRequest>` except the signature, but before we sign it, we have to initialize the signature field by setting it to a zero-byte placeholder.

.. highlight:: python

::

   request.signature = sign(private_key, request.SerializeToString(), "sha256")

``signature``: (required for signed :term:`PaymentRequests <PaymentRequest>`) now we make the :term:`signature <SSL signature>` by signing the completed and serialized :term:`PaymentRequest <PaymentRequest>`. We’ll use the private key we stored in memory in the configuration section and the same hashing formula we specified in :term:`“pki_type” <PP pki type>` (sha256 in this case)

Output Code
'''''''''''

Now that we have :term:`PaymentRequest <PaymentRequest>` all filled out, we can serialize it and send it along with the HTTP headers, as shown in the code below.

.. highlight:: python

::

   print "Content-Type: application/bitcoin-[paymentrequest][paymentrequest]"
   print "Content-Transfer-Encoding: binary"
   print ""

(Required) `BIP71 <https://github.com/bitcoin/bips/blob/master/bip-0071.mediawiki>`__ defines the content types for :term:`PaymentRequests <PaymentRequest>`, Payments, and PaymentACKs.

.. highlight:: python

::

   file.write(stdout, request.SerializeToString())

``request``: (required) now, to finish, we just dump out the serialized :term:`PaymentRequest <PaymentRequest>` (which contains the serialized :term:`PaymentDetails <PaymentDetails>`). The serialized data is in binary, so we can’t use Python’s print() because it would add an extraneous newline.

The following screenshot shows how the authenticated :term:`PaymentDetails <PaymentDetails>` created by the program above appears in the GUI from Bitcoin Core 0.9.

.. figure:: /img/dev/en-btcc-payment-request.png
   :alt: Bitcoin Core Showing Validated Payment Request

   Bitcoin Core Showing Validated Payment Request

.. |Warning icon| image:: /img/icons/icon_warning.svg

